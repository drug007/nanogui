## Компоненты

- парсер, разбирает исходный код (DSL) и строит модель
- модель, состоит из двух частей - данные, которые нужно обработать, и метаданные, необходимая для последующей обработки
- обходчик, обходит модель, используя метаданные. В процессе обхода он формирует последовательность данных и подает ее на вход обработчика
- обработчик, обрабатывает данные в соответствие с заложенным алгоритмом

Данные в модели это собственно исходные данные как они есть (задаются изначально), метаданные (формируются на основе данных при первоначальной их инициализации, а также в ходе обхода/обработки) позволяют более эффективно обходить модель, кешировать дорогостоящие операции и т.д.
Различие между обходчиком и обработчиком в том, что обходчик определяет порядок обхода модели, а обработчик определяет как эти данные будут обработаны. Например:

Обходчик может обойти модель в глубину или в ширину в прямом или обратном порядке (на данный момент рассматривается только обход в глубину, но нужно рассмотреть и обход в ширину). Обработчик может отрендерить узлы/листья горизонтально или вертикально. Т.о. обход детей задается на уровне обходчика, а ориентация задается на уровне обработчика.

#### Тесты для обходчика

Тест использует сложную структуру данных. По ней формируется модель во время компиляции и заполняется при запуске. Порядок обхода модели задается по умолчанию и может быть изменен при запуске путем модификации метаданных. (Примечание: нужен механизм добавления метаданных, чтобы их можно было не только формировать на основе данных, но и получать сразу с данными)
Поддерживаемые типы данных:
- встроенные
- строки
- динамические массивы и диапазоны
- статические массивы
- указатели
- агрегатные типы (тип произведение)
- тип сумма

Листьями модели (модель представляет собой несбаласированное гетерогенное дерево) являются (по умолчанию) указатели, встроенные типы и строки, остальные типы формируют узлы. Однако тип можно менять атрибутами во время компиляции, а тип сумма и во время исполнения.

+ ---------------------------------- + --------- +
| встроенные                         | лист      |
| строки                             | лист      |
| динамические массивы и диапазоны   | узел      |
| статические массивы                | узел      |
| указатели                          | лист      |
| агрегатные типы (тип произведение) | узел      |
| тип сумма                          | лист/узел |
+ ---------------------------------- + --------- +

struct Foo // узел
{
    string s; // лист
}

struct Bar // узел
{
    Foo[] foo; //узел
    int i; // лист
}

Метаданные для узла могут содержать, например, признак свернут/развернут узел, его размер, порядок обхода (прямой/обратный), ориентацию и другие характеристики. Метаданные позволяют рассматривать одни и те же данные по разному и предоставляют функциональность view.

### Решаемые задачи

Изначальный контекст - визуализация данных, но в целом может использоваться, например, для сериализации. Для этого данные обходятся и обрабатываются в соответствии с задачей - рендерятся/сериализуются/десериализуются. Обход членов структуры данных произвольной сложности (с допустимыми ограничениями?). Порядок обхода определяется:
- внешними условиями, заданными при начале обхода и неизменяющиеся во время обхода
- типом данных конкретного члена структуры данных
- атрибутами конкретного члена структуры данных (как времени компиляции, так и времени выполнения)

Для структуры данных формируется модель. Модель содержит метаинформацию, необходимую для обхода эффективного структуры данных. Обход осуществляется с помощью визитора. Обработка с помощью обработчика.

### Варианты обхода

Любая структура данных представляется в виде дерева. Корнем дерева является сама структура - ее тип и атрибуты. Члены структуры (здесь и далее - только публичные) формируют узлы и листья дерева. Агрегатные типы и массивы/ренжи формируют узлы, встроенные типы формируют листья. Агрегатные типы могут при необходимости формировать листья, равно как встроенные типы формировать узлы (просто в большинстве случае бессмысленно формировать поддерево из поля типа int - в нем просто нет каких-либо данных, разве что поле просто seed для генератора случайных чисел и остальные данные генерируются).

Узлы обходятся в глубину (неинформированный поиск с помощью рекурсивной функции, возможно наличие предела на глубину рекурсии), при этом есть доступ к непосредственному родительскому узлу (к остальным родительским узлам доступ не гарантируется). Каждый узел должен определять (через тип или атрибут):
- направление обхода (требуется только для узлов, включая корень дерева): прямой (от первого элемента к последнему) или обратный (в противоположном порядке)
- размер узла в его направлении обхода (включая всех его потомков), при этом размер узла в ортогональном направлении задается родительским узлом. Для корня размер по ортогональной оси задается в начале обхода

Первоначально известен размер только корня (задается в начале обхода) и листьев (заданы по умолчанию). Для расчета размеров узлов может осуществлятся отдельный обход.

Обход подразумевает 2D пространство, размер в одном измерении задается членом структуры данных, второе измерение для корня задается при начале обхода, для остальных формируется в родительском узле. В каждом измерении обход может осуществлятся по возрастанию (от первого члена к последнему), так и наоборот. Члены структуры данных отображаются в двумерной пространство в виде соприкасающихся плиток, каждый член отождествляется с единственной плиткой, плитки потомков полностью содержатся внутри плитки родительского узла. Пересечение плиток невозможно.

Критериями обхода в общем случае являются размеры окна (его начальная позиция и размеры), текущее состояние визитора (его текущее положение) и обходимой структурой данных (ее размером и размером ее членов). Если текущее положение визитора находится внутри текущего окна, то обход начинается и завершается когда текущее положение визитора покинет текущее окно по всем измерениям (возможна ситуация когда при обходе в некоторых узлах/листьях визитор выйдет за пределы окна в одном измерении, это не означает что нет других узлов, при обходе которых визитор останется внутри окна, поэтому обход должен быть исчерпывающим. Если в текущем измерение текущее окно было покинуто, то произходит возврат к родительскому узлу, имеющему другое измерение обхода и обход продолжается со следующего потомка данного узла и так пока не будут посещены все потомки исходного дерева)

Члены структуры индексированы и имеют tree path, который уникально идентифицирует каждого члена структуры. Обход структуры возможен с любого члена структуры, при этом допустимы накладные расходы на поиск данного типа - т.е. первоначально осуществляется обход структуры с целью найти заданный член, а затем обход с конечно целью (например, подсчет размера или непосредственно рендеринг)

На время обхода структура данных и ее модель считаются константными, изменяется только текущее состояние визитора. При необходимости изменения структуры данных во время обхода только собирается информация, необходимая для изменения и непосредственно изменение осуществляется после обхода.

Модель не содержит никаких исходных данных или ссылок/указателей на них, только метаданные. Исходные данные и модель используются вместе и дополняют друг друга без дублирования.

Исходные данные могут иметь скрытые элементы (здесь также имеются в виду публичные элементы, приватные/защищенные не затрагиваются вообще). Элемент может быть скрыт во время компиляции и во время исполнения.
Исходные данные могут быть подвергнуты сортировке также и во время компиляции, и во время исполнения. По умолчанию сортировки нет.

Пользователь передает (в функцию обхода?) шаблон, которые реализует предопределенную функциональность
Можно выделить три уровня исполнения:
* модель просто содержит отображение исходной структуры данных, не имеет никакого внутренного представления и предоставляет только возможность обхода структуры данных (при тестах проверяем какие были посещены члены/элементы и в каком порядке ), т.е. нет никакого состояния вообще
* модель получает дополнительно состояние, которое характеризует всю структуру данных в целом (, правильна ли была рассчитана ширина/высота структуры данных и ее элементов в процессе обхода), т.е. может быть состояние у каждого листа/узла, при этом состояния независимы друг от друга
* обходчик имеет состояние, которое характеризует структуру данных в момент обхода и сохраняется при переходе от текущего листа/узла к следующему (при тестах проверяем текущую позицию в момент обхода), т.е. есть каждый элемент может иметь состояние и это состояние может зависить от состояния других элементов